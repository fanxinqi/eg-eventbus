<html>

<head>
	<title>算法</title>
</head>

<body>
	看control
</body>
<script>
	//数组去重复
	//思路是用hash 存储，进行重复判断 时间复杂度o(n)
	!(function () {
		var arr = [1, 2, 3, 4, 1, 5, 6, 7, 9];
		var result = [],
			hashMap = {};
		for (var i = 0, e;
			(e = arr[i]) != null; i++) {
			if (!hashMap[e]) {
				result.push(e);
				hashMap[e] = true;
			}
		}
		console.log(result)
	})();


	//斐波那契数列 生成 fn(n)=fn(n-1)+fn(n-2) n>2,fn(1)=1,f(2)=2
	!(function () {

		var x = 1;
		//递归实现：时间复杂度：o(2的n次方) ，由于有重复计算 二叉树
		function fb1(n) {
			console.log(x)
			x++;
			if (n <= 2) {
				return 1;
			}
			return fb1(n - 1) + fb1(n - 2);
		}
		//尾递归优化：时间复杂度 o(n)
		function fb2(n, res1 = 1, res2 = 1) {
			console.log(x)
			x++;
			if (n <= 2) {
				return res2;
			}
			return fb2(n - 1, res2, res2 + res1);
		}
		console.time();
		console.log(fb2(10));
		console.timeEnd();
		//动态规划：
		function dynFib(n) {
            let val = [];
            for(let i = 0; i <= n; ++i){
                val[i]=0;
            }
            if(n ===1 || n  === 2){
                return 1;
            }
            else {
                val[1] =1;
                val[2] = 2;
                for(let i = 3; i <= n; ++i){
                    val[i] = val[i-1] +val[i-2] ;
                }
            }
            return val[n-1]
        }
		console.time();
		console.log(dynFib(10));
		console.timeEnd();

	})();
</script>

</html>